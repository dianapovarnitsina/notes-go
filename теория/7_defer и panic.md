### defer и panic

#### defer
Оператор defer позволяет выполнить определенную функцию в конце программы, при этом не важно, где в реальности вызывается эта функция. <br>


Функции вызванные с ключевым словом defer
Складываются в defer stack функции и выполняются в порядке обратном добавлению при выходе из функции (т.е. 
если несколько функций вызываются с оператором defer, то те функции, которые вызываются раньше, будут выполняться позже всех).


```go
package main
import  "fmt"
 
func main() {
      
    defer finish()
    defer fmt.Println("Program has been started")
    fmt.Println("Program is working")
}
 
func finish(){
    fmt.Println("Program has been finished")
}
```

Вычисление значений deferred функций:

```go
package main

import (
	"fmt"
)

func main() {
	fmt.Println(sum(2, 3))
	deferValues()
}


func sum(x, y int) (sum int) {
	defer func() {
		sum *= 2 //умножает на 2 полученный результат при выходе
	}()

	sum = x + y
	return
} 


func deferValues() {

	for i := 0; i < 10; i++ {
		defer fmt.Println("first", i) //выводит от 9 до 0
	}
	
	//Когда цикл выполняется, каждый вызов fmt.Println добавляется в стек отложенных функций в порядке от 9 до 0. 
	//Затем, когда цикл завершается, стек выполняется в обратном порядке, и каждая функция выводит свое значение i, 
	//которое было актуальным на момент добавления функции в стек. 
	//Это происходит, потому что defer запоминает значение i на момент добавления вызова функции в стек, а не на момент выполнения этой функции.

	for i := 0; i < 10; i++ {
		defer func() {
			fmt.Println("second", i) // выводит 10, потому что на момент вызова i=10, т.к. в функцию не передаются значения
		}()
	}

	//Пояснение к верхней:
	//Когда defer получает анонимную функцию, он также захватывает контекст, включая значения переменных, 
	//которые используются в этой анонимной функции (в данном случае, переменную i). 
	//Таким образом, при каждой итерации цикла, создается отдельная анонимная функция, которая захватывает ссылку на переменную i.

	//Когда цикл завершается, значение i становится равным 10 (последнее значение цикла). 
	//Затем, когда выполняются анонимные функции из defer, они выводят значение переменной i, на которую ссылались при создании. 
	//И так как все анонимные функции ссылались на одну и ту же переменную i, они выводят её текущее значение, которое и равно 10.
	

	//Варианты как можно избежать вышеописанной ситуации:
	for i := 0; i < 10; i++ {
		k := i
		defer func() {
			fmt.Println("third", k) //выводит от 9 до 0
		}()
	}
	
	//Каждая итерация цикла создает свою собственную переменную k с уникальным значением, равным текущему значению i на момент создания. 
	//Затем каждая анонимная функция, переданная в defer, ссылается на свою собственную переменную k.

	//Поскольку каждая анонимная функция ссылается на свою уникальную переменную k, 
	//которая имеет свое собственное значение в каждой итерации, при выполнении defer эти значения выводятся в обратном порядке от 9 до 0.

	for i := 0; i < 10; i++ {
		defer func(k int) {
			fmt.Println("fourth", k) //выводит от 9 до 0
		}(i)
	}
	
	//Каждая итерация цикла создает свою собственную анонимную функцию с уникальным значением k, равным текущему значению i на момент создания функции. 
	//Затем каждая анонимная функция выводит свое уникальное значение k, которое является копией значения i на момент создания функции.

	//Таким образом, в вашем последнем коде выводятся значения k от 9 до 0, потому что каждая анонимная функция запоминает свое собственное значение k,
}
```

#### panic
Оператор panic позволяет сгенерировать ошибку и выйти из программы:

```go
package main

import (
	"fmt"
)

func main() {

	makePanic()
	fmt.Println("работаем дальше")
}

func makePanic() {

	defer func() {
		panicValue := recover()
		fmt.Println(panicValue)
	}()

	panic("some panic")
	fmt.Println("Unreachable code")
}
```

В функции makePanic() происходит вызов паники с помощью panic("some panic"). 
Это означает, что программа будет прекращена, и управление передастся к функции с отложенным вызовом (defer).
Функция с отложенным вызовом выполняется. Она использует recover() для восстановления значения паники, которое было передано panic("some panic").
Затем функция выводит значение восстановленной паники, которое в данном случае равно строке "some panic".
Далее продолжается выполнение main, а именно печатается "работаем дальше".
Обратить внимание: "Unreachable code" не выводится, так как происходит прерывание выполнения в момент паники.
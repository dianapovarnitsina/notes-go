### Массивы

В отличие от слайсов и мап, при присваивании массива другой переменной или передаче массива в функцию `происходит копирование его значений`, 
а не передача ссылки на оригинальный массив.

Массивы представляют последовательность элементов определенного типа.

При создании массива все содержащиеся в нем элементы инициализируются нулевым значением для типа, хранящегося в массиве.

```text
var numbers [число_элементов]тип_элементов
```

```go
// Все элементы массива инициализируются значениями по умолчанию
var numbers [5]int
var numbers [5][5]int //многомерный

// Инициализация другими значениями. Значений не может быть больше длины массива. Но можно определить меньше элементов
var numbers [5]int = [5]int{1,2,3,4,5} // {1,2,3,4,5} - это литералы массива
var numbers [5]int = [5]int{1,2}

//сокращенное определение переменной массива
numbers := [5]int{1,2,3,4,5}

//Если в квадратных скобках вместо длины указано троеточие, то длина массива определяется, исходя из количества переданных ему элементов
var numbers = [...]int{1,2,3,4,5}   // длина массива 5
numbers2 := [...]int{1,2,3}         // длина массива 3

//!!!! Длина массива является частью его типа. 
// Следующие два массива представляют разные типы данных, хотя они и хранят данные одного типа
// При присвоении мы получим ошибку, так как данные одного типа пытаемся передать переменной другого типа.
var numbers [3]int = [3]int{1, 2, 3}
var numbers2 [4]int = [4]int{1, 2, 3, 4}
numbers = numbers2  // ! Ошибка 

var numbers [5]int = [5]int{1,2,3,4,5}
fmt.Println(numbers[0])     // 1
fmt.Println(numbers[4])     // 5
numbers[0] = 87
fmt.Println(numbers[0])     // 87

//Массив можно перебирать в цикле
notes := [7]string{"do", "re", "mi", "fa", "so", "la", "si"} 
for i := 0; i <= 6; i++ {  
	fmt.Println(i, notes[i]) 
}
//Вывод
//0 do
//1 re
//2 mi
//3 fa
//4 so
//5 la
//6 ti

//или
for index, note := range notes { //index - хранит индексы, note - хранит значение, range - ключевое слово, notes - перебираемый массив
	fmt.Println(index, note) 
}
//Вывод
//0 do
//1 re
//2 mi
//3 fa
//4 so
//5 la
//6 ti

//Вывод только элементов
for _, note := range notes { //index - хранит индексы, note - хранит значение, range - ключевое слово, notes - перебираемый массив
    fmt.Println(note)
}

//получить длину массива 
notes := [7]string{"do", "re", "mi", "fa", "so", "la", "ti"} 
l := len(notes)
fmt.Println(l) // 7
x := cap(notes)
fmt.Println(x) // 7
```

Вывод
```go
var z = [3]int{1, 2, 3}
fmt.Printf("%#v\n", z)
//вывод: [3]int{1, 2, 3}
```

Выше используется упорядоченный список значений, НО можно также указать список пар “индекс-значение”.
Индексы можно указывать в любом порядке, также они могут быть опущены;
Неуказанные значения получают нулевое значение типа элемента.
```go
    r := [...]int{9: -1}    //9 - это индекс, -1 - это значение
    fmt.Println(r)          //Вывод: [0 0 0 0 0 0 0 0 0 -1]

//ИЛИ

    type Currency int

	const (
		USD Currency = iota
		EUR
		GBP
		RUR
	)

	symbol := [...]string{USD: "+", EUR: "++", GBP: "+++", RUR: "++++"}
    fmt.Println(symbol) //Вывод: [+ ++ +++ ++++]
	fmt.Println(RUR, symbol[RUR]) //Вывод: 3 ++++
```

### Сравнение массивов

```go
	a := [2]int{1, 2}
	b := [...]int{1, 2}
	c := [2]int{1, 3}
	fmt.Printf("%#v\n", a) //[2]int{1, 2}
	fmt.Printf("%#v\n", b) //[2]int{1, 2}
	fmt.Printf("%#v\n", c) //[2]int{1, 2}
	fmt.Println(a == b, a == c, b == c) // "true false false" потому что тип у всех 3х массивов [2]int
	d := [3]int{1, 2} 
    fmt.Printf("%#v\n", d) //[3]int{1, 2, 0}
	fmt.Println(a == d) // Ошибка компиляции: разные типы [2]int и [3]int
```

###  Многомерные массивы

```go
//Двумерный массив
var matrix [3][3]int
matrix := [2][3]int{{1, 2, 3}, {4, 5, 6}} // инициализация

//Трехмерный массив:
var cube [2][2][2]int
cube := [2][2][2]int{
	{
		{1, 2},
        {3, 4},
    },
    {
        {5, 6},
        {7, 8},
    },
}

matrix := [2][3]int{{1, 2, 3}, {4, 5, 6}}
fmt.Println(matrix[0][1]) // Вывод: 2
```

При вызове функции копия каждого значения аргумента присваивается переменной соответствующего параметра, 
так что функция получает копию, а не оригинал.  <br>
Передача таким образом больших массивов может быть неэффективной, а любые изменения, 
вносимые функцией в элементы массива, будут влиять только на копию, но не на оригинал.

Можно явно передать указатель на массив, так что любые изменения, 
которые функция будет делать в элементах массива, будут видны вызывающей функции.

```go
package main

import (
	"crypto/sha256"
	"fmt"
)

func zero(ptr *[32]byte) {
	for i := range ptr {
		ptr[i] = 0
	}
}

func main() {
	c1 := sha256.Sum256([]byte("x"))

	fmt.Println(c1)
	zero(&c1)
	fmt.Println(c1)
}

// Вывод: 
// [45 113 22 66 183 38 176 68 1 98 124 169 251 172 50 245 200 83 15 177 144 60 196 219 2 37 135 23 146 26 72 129]
// [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
```

Массивы остаются негибким решением из-за фиксированного размера. 

Например, функция zero не примет указатель на переменную [16]byte; 
Нет возможно добавить или удалить элемент массива.

По этим причинам, за исключением особых случаев, таких как хеш SHA256 фиксированного размера, 
массивы в качестве параметров функции используются редко; вместо этого обычно используются срезы.


